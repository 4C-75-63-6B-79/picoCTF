# READ THIS
# We know that e is small
# so what we can do here is we can multiply n with integers and add c to the product like this n * i + c where i is (0,1,2,3,4....) 
# then what we can do is find the  eth root of the obatined value
# we can then convert the eth root to hex value and see if the hex value of pico which is 7069636f is present in that if yes then we convert that to plain text
# nth_power and the nth_pow helps us to find the root. Both functions do the same thing but the nth_power takes less time as it calculates a better value for the lower limit
# both functions use binary search to find the root you can google it.
# To use this solution just paste the value of your n, c and e value in the lower given variables and run it 
# After runnig it please be patient it takes FEW SECONDS TO PRINT THE RESULT
# this solution worked for me but it might not for you because I might have made some mistake so sorry

import binascii

def nth_power(number, root): #optimized
    upper_limit = 1;
    while upper_limit ** root <= number:
        upper_limit *= 2;

    lower_limit = upper_limit // 2;
    mid = 0;
    while(lower_limit < upper_limit):
        mid = ( upper_limit + lower_limit ) // 2;
        mid_nth = mid ** root;

        if(lower_limit < mid and mid_nth < number):
            lower_limit = mid;
        elif(upper_limit > mid and mid_nth > number):
            upper_limit = mid;
        else:
            return mid
    return mid + 1;


# i think that we take the words and covert them into some hex
# add a bunch of gibbrish to it and then convert that number to the int
# then do rsa shit on it
# like so our data is picoCTF{e_sh0u1d_b3_lArg3r_85d643d5} to hex using binascii.hexlify(b'string')
# convert to hex 7069636f4354467b655f7368307531645f62335f6c41726733725f38356436343364357d
# added useless to front 20202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020207069636f4354467b655f7368307531645f62335f6c41726733725f38356436343364357d
# then convert this to int using int(hex, 16) which is the nth root get this 1787330808968142828287809319332701517353332911736848279839502759158602467824780424488141955644417387373185756944952906538004355347478978500948630620749868180414755933760446136287315896825929319145984883756667607031853695069891380871892213007874933611243319812691520078269033745367443951846845107464675742664639073699944730122897078891901
# then do the rsa thing on it which was our problem


def nth_pow(num, root): # unoptimized
    low = 0;
    high = num;
    ans = 0;
    while low <= high:
        mid = (low + high) // 2;

        if(mid ** root == num):
            return mid

        if(mid ** root < num):
            low = mid + 1;
            ans = mid;
        else:
            high = mid - 1;

    return ans;


# number = int(input('enter the number'))
# root = int(input('enter the root'));

#print(nth_pow(number, root))

n = 1615765684321463054078226051959887884233678317734892901740763321135213636796075462401950274602405095138589898087428337758445013281488966866073355710771864671726991918706558071231266976427184673800225254531695928541272546385146495736420261815693810544589811104967829354461491178200126099661909654163542661541699404839644035177445092988952614918424317082380174383819025585076206641993479326576180793544321194357018916215113009742654408597083724508169216182008449693917227497813165444372201517541788989925461711067825681947947471001390843774746442699739386923285801022685451221261010798837646928092277556198145662924691803032880040492762442561497760689933601781401617086600593482127465655390841361154025890679757514060456103104199255917164678161972735858939464790960448345988941481499050248673128656508055285037090026439683847266536283160142071643015434813473463469733112182328678706702116054036618277506997666534567846763938692335069955755244438415377933440029498378955355877502743215305768814857864433151287
c = 1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808147276605782889813772992918898400408026067642464141885067379614918437023839625205930332182990301333585691581437573708925507991608699550931884734959475780164693178925308303420298715231388421829397209435815583140323329070684583974607064056215836529244330562254568162453025117819569708767522400676415959028292550922595255396203239357606521218664984826377129270592358124859832816717406984802489441913267065210674087743685058164539822623810831754845900660230416950321563523723959232766094292905543274107712867486590646161628402198049221567774173578088527367084843924843266361134842269034459560612360763383547251378793641304151038512392821572406034926965112582374825926358165795831789031647600129008730
e = 3


for i in range(4000):
    nth_root = nth_power(c+i*n,3)
    st = ("{:x}".format(nth_root))
    if "7069636f" in st:
        print(nth_root)
        print('--------------------------')
        print(st)
        print('--------------------------')
        print(binascii.unhexlify(st));

